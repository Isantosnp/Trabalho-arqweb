üöÄ  API de Autentica√ß√£o e Autoriza√ß√£o JWT (Emiss√£o e Valida√ß√£o Interna)
Este roteiro te guiar√° na constru√ß√£o de uma API Spring Boot que √© o cora√ß√£o da sua autentica√ß√£o. Ela ser√° respons√°vel por gerar tokens JWT para usu√°rios que fizerem login e por validar esses mesmos tokens para proteger seus seus pr√≥prios recursos.
Abordaremos as melhores pr√°ticas:

seguran√ßa,
testabilidade e
documenta√ß√£o.
1. üì¶ Depend√™ncias do Projeto
Pra come√ßar, adicione as depend√™ncias essenciais no seu pom.xml. As vers√µes mais recentes do Spring Boot 3.x garantem que tudo funcione perfeitamente.

spring-boot-starter-web: üåê Pra construir suas APIs RESTful.

Documenta√ß√£o Oficial Spring WebLinks para um site externo.

spring-boot-starter-security: üîí O core da seguran√ßa do Spring, pra autentica√ß√£o e autoriza√ß√£o.

Documenta√ß√£o Oficial Spring SecurityLinks para um site externo.

spring-boot-starter-oauth2-resource-server: üîë Permite que sua API valide tokens JWT, agindo como um Servidor de Recursos.

Documenta√ß√£o Oficial Spring Security OAuth2 Resource ServerLinks para um site externo.

spring-boot-starter-data-jpa: üóÑÔ∏è Pra persist√™ncia de dados usando JPA.

Documenta√ß√£o Oficial Spring Data JPALinks para um site externo.

com.h2database:h2: üíæ Banco de dados em mem√≥ria, perfeito pra desenvolvimento e testes.

Documenta√ß√£o Oficial H2 DatabaseLinks para um site externo.

org.springdoc:springdoc-openapi-starter-webmvc-ui: üìö Gera a documenta√ß√£o autom√°tica da sua API com Swagger UI.

Documenta√ß√£o Oficial Springdoc OpenAPILinks para um site externo.

org.springframework.boot:spring-boot-devtools: üõ†Ô∏è Ferramentas que aceleram o desenvolvimento, como "hot reload".

Documenta√ß√£o Oficial Spring Boot DevToolsLinks para um site externo.

org.projectlombok:lombok: üç¨ Reduz aquele c√≥digo repetitivo (getters, setters, etc.).

Documenta√ß√£o Oficial LombokLinks para um site externo.

org.springframework.boot:spring-boot-starter-test: ‚úÖ Inclui JUnit 5 e Mockito, essenciais pra testes.

Documenta√ß√£o Oficial Spring Boot TestingLinks para um site externo.

2. ‚öôÔ∏è Configura√ß√£o do Ambiente de Desenvolvimento (application.yml)
Configure o arquivo src/main/resources/application.yml. Ele controla como sua API vai se comportar, incluindo as chaves e tempos de expira√ß√£o dos seus JWTs.

# application.yml

# üöÄ Configura√ß√µes do Servidor Web
server:
  port: 8080 # Porta padr√£o para a sua API

# üóÑÔ∏è Configura√ß√µes do Banco de Dados H2
spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE # H2 em mem√≥ria, n√£o fecha o banco. √ötil para desenvolvimento.
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true # Habilita o console do H2
      path: /h2-console # Acesse em http://localhost:8080/h2-console
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update # Cria/atualiza o schema do DB automaticamente. **N√ÉO USE EM PRODU√á√ÉO!**
    show-sql: true # Exibe as queries SQL no console (√≥timo para depura√ß√£o)
    properties:
      hibernate:
        format_sql: true # Formata o SQL para melhor legibilidade no console

# üõ†Ô∏è Spring DevTools: Otimizando o Desenvolvimento
  devtools:
    restart:
      enabled: true # Reinicia a app automaticamente ao detectar mudan√ßas no c√≥digo
    livereload:
      enabled: true # Habilita o LiveReload (requer extens√£o no navegador)

# üîí Configura√ß√µes JWT para Gera√ß√£o e Valida√ß√£o Interna
# IMPORTANTE: EM PRODU√á√ÉO, A CHAVE SECRETA DEVE SER UMA VARI√ÅVEL DE AMBIENTE OU GERENCIADA POR UM SERVI√áO DE SECRETS!
jwt:
  secret: umaChaveSecretaMuitoLongaEComplexaParaAssinarTokensJWT # Use uma string longa, aleat√≥ria e segura (m√≠nimo de 32 caracteres para HMAC256).
  expiration: 3600000 # Tempo de expira√ß√£o do token em milissegundos (aqui: 1 hora)

# üìö Springdoc OpenAPI (Swagger): Documenta√ß√£o da API
springdoc:
  swagger-ui:
    path: /swagger-ui.html # Caminho para a interface do Swagger UI
    disable-swagger-default-url: true # Evita carregar a URL padr√£o do Swagger (Petstore)
  api-docs:
    path: /v3/api-docs # Caminho para os arquivos de defini√ß√£o da API (JSON/YAML)

3. üõ°Ô∏è Implementa√ß√£o da API de Autentica√ß√£o
3.1. Entidade de Usu√°rio (User.java)
// src/main/java/com/example/authserver/model/User.java
package com.example.authserver.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import jakarta.persistence.*;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @Column(unique = true, nullable = false)
    private String username;
    @Column(nullable = false)
    private String password; // Senha codificada
    @Column(nullable = false)
    private String role; // Ex: "ADMIN", "USER"
}

3.2. Reposit√≥rio de Usu√°rio (UserRepository.java)
// src/main/java/com/example/authserver/repository/UserRepository.java
package com.example.authserver.repository;

import com.example.authserver.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}

3.3. Servi√ßo de Gera√ß√£o e Valida√ß√£o de Tokens JWT (JwtService.java)
Este √© o componente central pra criar e verificar seus pr√≥prios JWTs.

// src/main/java/com/example/authserver/service/JwtService.java
package com.example.authserver.service;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Service
public class JwtService {

    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.expiration}")
    private long expirationTime;

    /**
     * Gera um token JWT com base nas informa√ß√µes do usu√°rio.
     * @param username O nome de usu√°rio (ser√° o 'subject' do token).
     * @param role A role (perfil) do usu√°rio (adicionada como 'claim').
     * @return O token JWT assinado.
     */
    public String generateToken(String username, String role) {
        return JWT.create()
                .withSubject(username)
                .withClaim("role", role)
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + expirationTime))
                .sign(Algorithm.HMAC256(secretKey)); // Assina com HMAC256 e sua chave secreta
    }

    /**
     * Valida um token JWT.
     * @param token O token JWT a ser validado.
     * @return true se o token for v√°lido e n√£o expirado, false caso contr√°rio.
     */
    public boolean validateToken(String token) {
        try {
            JWT.require(Algorithm.HMAC256(secretKey)).build().verify(token);
            return true;
        } catch (JWTVerificationException e) {
            System.err.println("Erro na valida√ß√£o do token: " + e.getMessage());
            return false;
        }
    }

    /**
     * Extrai o nome de usu√°rio (subject) de um token JWT.
     * @param token O token JWT.
     * @return O username.
     */
    public String getUsernameFromToken(String token) {
        return JWT.decode(token).getSubject();
    }

    /**
     * Extrai todas as claims de um token JWT.
     * @param token O token JWT.
     * @return Um mapa com as claims do token.
     */
    public Map<String, Object> getAllClaimsFromToken(String token) {
        return JWT.decode(token).getClaims().entrySet().stream()
                   .collect(HashMap::new, (map, entry) -> map.put(entry.getKey(), entry.getValue().asString()), HashMap::putAll);
    }
}

3.4. Servi√ßo de Autentica√ß√£o (AuthService.java)
Lida com a l√≥gica de neg√≥cio de autentica√ß√£o de credenciais.

// src/main/java/com/example/authserver/service/AuthService.java
package com.example.authserver.service;

import com.example.authserver.model.User;
import com.example.authserver.repository.UserRepository;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService; // Injeta o servi√ßo de JWT

    public AuthService(UserRepository userRepository, PasswordEncoder passwordEncoder, JwtService jwtService) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
        this.jwtService = jwtService;
    }

    /**
     * Autentica um usu√°rio e, se bem-sucedido, gera e retorna um token JWT.
     * @param username Nome de usu√°rio.
     * @param password Senha em texto claro.
     * @return O token JWT.
     * @throws BadCredentialsException Se as credenciais forem inv√°lidas.
     */
    public String authenticateUserAndGenerateToken(String username, String password) {
        Optional<User> userOptional = userRepository.findByUsername(username);

        if (userOptional.isEmpty()) {
            throw new BadCredentialsException("Credenciais inv√°lidas: Usu√°rio n√£o encontrado.");
        }

        User user = userOptional.get();

        if (!passwordEncoder.matches(password, user.getPassword())) {
            throw new BadCredentialsException("Credenciais inv√°lidas: Senha incorreta.");
        }

        return jwtService.generateToken(user.getUsername(), user.getRole());
    }
}

3.5. Controlador de Autentica√ß√£o (AuthController.java)
Exp√µe os endpoints pra login e valida√ß√£o.

// src/main/java/com/example/authserver/controller/AuthController.java
package com.example.authserver.controller;

import com.example.authserver.service.AuthService;
import com.example.authserver.service.JwtService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/auth")
@Tag(name = "Autentica√ß√£o", description = "Endpoints para login e gera√ß√£o/valida√ß√£o de tokens JWT")
public class AuthController {

    private final AuthService authService;
    private final JwtService jwtService;

    public AuthController(AuthService authService, JwtService jwtService) {
        this.authService = authService;
        this.jwtService = jwtService;
    }

    @Operation(summary = "Realiza o login do usu√°rio e emite um token JWT")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Login bem-sucedido, retorna o token JWT"),
        @ApiResponse(responseCode = "401", description = "Credenciais inv√°lidas")
    })
    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestParam String username, @RequestParam String password) {
        try {
            String token = authService.authenticateUserAndGenerateToken(username, password);
            return ResponseEntity.ok(token);
        } catch (BadCredentialsException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(e.getMessage());
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Ocorreu um erro interno ao tentar logar.");
        }
    }

    @Operation(summary = "Valida um token JWT (√∫til para debug e verifica√ß√£o externa)")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Token v√°lido"),
        @ApiResponse(responseCode = "401", description = "Token inv√°lido ou expirado")
    })
    @PostMapping("/validate")
    public ResponseEntity<String> validateToken(@RequestParam String token) {
        if (jwtService.validateToken(token)) {
            return ResponseEntity.ok("Token v√°lido! Username: " + jwtService.getUsernameFromToken(token));
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Token inv√°lido ou expirado.");
        }
    }
}

4. üîë Configura√ß√£o do Spring Security para JWT (Valida√ß√£o Interna)
Aqui, configuramos o Spring Security pra usar sua pr√≥pria chave secreta pra decodificar e validar os JWTs que sua API emitiu.

// src/main/java/com/example/authserver/config/SecurityConfig.java
package com.example.authserver.config;

import com.example.authserver.model.User;
import com.example.authserver.repository.UserRepository;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.boot.CommandLineRunner;

import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
import org.springframework.beans.factory.annotation.Value;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Value("${jwt.secret}")
    private String jwtSecret;

    // PasswordEncoder: Pra codificar senhas de forma segura
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    // UserDetailsService: Como o Spring Security vai carregar os detalhes do usu√°rio
    @Bean
    public UserDetailsService userDetailsService(UserRepository userRepository) {
        return username -> userRepository.findByUsername(username)
                .map(user -> org.springframework.security.core.userdetails.User.builder()
                        .username(user.getUsername())
                        .password(user.getPassword())
                        .roles(user.getRole())
                        .build())
                .orElseThrow(() -> new UsernameNotFoundException("Usu√°rio n√£o encontrado: " + username));
    }

    // JwtDecoder: O componente que o Spring Security usa pra decodificar e validar JWTs
    @Bean
    public JwtDecoder jwtDecoder() {
        // A chave secreta √© convertida pra um SecretKeySpec para HMAC
        SecretKeySpec secretKey = new SecretKeySpec(jwtSecret.getBytes(StandardCharsets.UTF_8), "HmacSha256");
        // Constr√≥i o NimbusJwtDecoder com a chave secreta. Ele far√° a valida√ß√£o da assinatura.
        return NimbusJwtDecoder.withSecretKey(secretKey).build();
    }

    // SecurityFilterChain: Configura as regras de seguran√ßa HTTP
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable) // Desabilita CSRF pra APIs RESTful stateless
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // API n√£o manter√° estado de sess√£o
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/auth/login").permitAll() // Permite acesso p√∫blico ao login
                .requestMatchers("/auth/validate").permitAll() // Permite acesso p√∫blico ao endpoint de valida√ß√£o
                .requestMatchers("/h2-console/**").permitAll() // Console H2
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll() // Documenta√ß√£o Swagger
                .anyRequest().authenticated() // Qualquer outra requisi√ß√£o exige um JWT v√°lido
            )
            .headers(headers -> headers.frameOptions(frameOptions -> headers.frameOptions().sameOrigin())) // Necess√°rio para o H2 console
            .oauth2ResourceServer(oauth2 -> oauth2.jwt(jwt -> {
                // Ao chamar .jwt(), o Spring Security usar√° o JwtDecoder que definimos como um Bean.
            }));

        return http.build();
    }

    // CommandLineRunner: Popula o banco de dados H2 com usu√°rios iniciais ao iniciar a aplica√ß√£o
    @Bean
    public CommandLineRunner initData(UserRepository userRepository, PasswordEncoder passwordEncoder) {
        return args -> {
            if (userRepository.findByUsername("admin").isEmpty()) {
                User admin = new User(null, "admin", passwordEncoder.encode("123456"), "ADMIN");
                userRepository.save(admin);
                System.out.println("‚úÖ Usu√°rio 'admin' criado com senha codificada.");
            }
            if (userRepository.findByUsername("user").isEmpty()) {
                User user = new User(null, "user", passwordEncoder.encode("password"), "USER");
                userRepository.save(user);
                System.out.println("‚úÖ Usu√°rio 'user' criado com senha codificada.");
            }
        };
    }
}

Pra testar seus endpoints protegidos e a autoriza√ß√£o baseada em roles, crie um controlador de exemplo:

// src/main/java/com/example/authserver/controller/TestProtectedController.java
package com.example.authserver.controller;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api")
@Tag(name = "Recursos Protegidos", description = "Endpoints que exigem autentica√ß√£o JWT")
@SecurityRequirement(name = "bearerAuth") // Indica que este controller requer um JWT v√°lido
public class TestProtectedController {

    @Operation(summary = "Endpoint acess√≠vel por qualquer usu√°rio autenticado")
    @GetMapping("/hello")
    public String hello() {
        return "Ol√°! Voc√™ acessou um endpoint protegido com sucesso!";
    }

    @Operation(summary = "Endpoint acess√≠vel apenas por usu√°rios com a role 'ADMIN'")
    @GetMapping("/admin")
    @PreAuthorize("hasRole('ADMIN')") // Exige que o JWT do usu√°rio tenha a role 'ADMIN'
    public String adminOnly() {
        return "Bem-vindo, Administrador! Este √© um recurso restrito.";
    }
}

5. ‚úÖ Testes com JUnit
Escreva testes robustos pra validar o fluxo de autentica√ß√£o, a gera√ß√£o de tokens e a prote√ß√£o de endpoints.

// src/test/java/com/example/authserver/AuthIntegrationTests.java
package com.example.authserver;

import com.example.authserver.repository.UserRepository;
import com.example.authserver.service.AuthService;
import com.example.authserver.service.JwtService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.security.crypto.password.PasswordEncoder;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.hamcrest.Matchers.notNullValue;
import static org.hamcrest.Matchers.containsString;

@SpringBootTest
@AutoConfigureMockMvc
class AuthIntegrationTests {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private AuthService authService;
    
    @Autowired
    private JwtService jwtService;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @BeforeEach
    void setup() {
        userRepository.findByUsername("admin").ifPresentOrElse(
                user -> { /* J√° existe */ },
                () -> {
                    com.example.authserver.model.User admin = new com.example.authserver.model.User(null, "admin", passwordEncoder.encode("123456"), "ADMIN");
                    userRepository.save(admin);
                }
        );
        userRepository.findByUsername("user").ifPresentOrElse(
                user -> { /* J√° existe */ },
                () -> {
                    com.example.authserver.model.User regularUser = new com.example.authserver.model.User(null, "user", passwordEncoder.encode("password"), "USER");
                    userRepository.save(regularUser);
                }
        );
    }

    @Test
    void testLoginSuccess() throws Exception {
        mockMvc.perform(post("/auth/login")
                .param("username", "admin")
                .param("password", "123456")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED))
               .andExpect(status().isOk())
               .andExpect(content().string(notNullValue()))
               .andExpect(content().string(s -> jwtService.validateToken(s)));
    }

    @Test
    void testLoginFailureInvalidPassword() throws Exception {
        mockMvc.perform(post("/auth/login")
                .param("username", "admin")
                .param("password", "senhaErrada")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED))
               .andExpect(status().isUnauthorized())
               .andExpect(content().string(containsString("Senha incorreta.")));
    }

    @Test
    void testProtectedEndpointAccessDeniedWithoutToken() throws Exception {
        mockMvc.perform(get("/api/hello"))
               .andExpect(status().isUnauthorized());
    }

    @Test
    void testProtectedEndpointAccessWithValidToken() throws Exception {
        String token = mockMvc.perform(post("/auth/login")
                .param("username", "user")
                .param("password", "password")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED))
               .andExpect(status().isOk())
               .andReturn().getResponse().getContentAsString();

        mockMvc.perform(get("/api/hello")
                .header("Authorization", "Bearer " + token))
               .andExpect(status().isOk())
               .andExpect(content().string("Ol√°! Voc√™ acessou um endpoint protegido com sucesso!"));
    }

    @Test
    void testProtectedAdminEndpointAccessWithAdminToken() throws Exception {
        String adminToken = mockMvc.perform(post("/auth/login")
                .param("username", "admin")
                .param("password", "123456")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED))
               .andExpect(status().isOk())
               .andReturn().getResponse().getContentAsString();

        mockMvc.perform(get("/api/admin")
                .header("Authorization", "Bearer " + adminToken))
               .andExpect(status().isOk())
               .andExpect(content().string("Bem-vindo, Administrador! Este √© um recurso restrito."));
    }

    @Test
    void testProtectedAdminEndpointAccessDeniedWithUserToken() throws Exception {
        String userToken = mockMvc.perform(post("/auth/login")
                .param("username", "user")
                .param("password", "password")
                .contentType(MediaType.APPLICATION_FORM_URLENCODED))
               .andExpect(status().isOk())
               .andReturn().getResponse().getContentAsString();

        mockMvc.perform(get("/api/admin")
                .header("Authorization", "Bearer " + userToken))
               .andExpect(status().isForbidden());
    }
}

6. üìà Testes de Carga com JMeter
O JMeter √© essencial pra simular muitos usu√°rios e requisi√ß√µes, avaliando o desempenho da sua API.

6.1. Instala√ß√£o do JMeter
Baixar: Acesse Apache JMeter DownloadsLinks para um site externo..

Extrair: Descompacte o arquivo.

Executar: No diret√≥rio bin, execute jmeter.bat (Windows) ou jmeter.sh (Linux/macOS).

6.2. Criando um Plano de Teste de Carga para Login
Novo Test Plan: No JMeter, v√° em File > New.

Adicionar Thread Group: Clique direito em Test Plan > Add > Threads (Users) > Thread Group.

Number of Threads (users): Por exemplo, 200 (simular 200 usu√°rios simult√¢neos).

Ramp-up period (seconds): Por exemplo, 20 (os 200 usu√°rios iniciar√£o ao longo de 20 segundos).

Loop Count: Por exemplo, 10 (cada usu√°rio far√° 10 requisi√ß√µes de login). Para um teste cont√≠nuo, selecione Forever.

Adicionar HTTP Request (Login): Clique direito no Thread Group > Add > Sampler > HTTP Request.

Name: Login Request

Protocol: http

Server Name or IP: localhost

Port Number: 8080

Method: POST

Path: /auth/login

Parameters: Na se√ß√£o "Parameters", clique em "Add" e adicione:

username: admin

password: 123456

Adicionar Listeners (para Visualizar Resultados):

Clique direito no Thread Group > Add > Listener > View Results Tree.

Clique direito no Thread Group > Add > Listener > Summary Report.

Image of JMeter Summary Report showing average response time, throughput, and error percentagestackoverflow.com
Executar o Teste: Clique no bot√£o verde Start (ou Ctrl + R). Deixe o teste rodar at√© que as requisi√ß√µes sejam conclu√≠das ou o tempo configurado expire.

Analisar os Relat√≥rios: Ap√≥s a execu√ß√£o, verifique os Listeners que voc√™ adicionou.

No Summary Report, voc√™ ver√° m√©tricas consolidadas como Average (Tempo M√©dio de Resposta), Error % (Porcentagem de Erros), Throughput (Requisi√ß√µes por segundo), etc. Isso te d√° uma vis√£o geral do desempenho.

No View Results Tree, voc√™ pode inspecionar cada requisi√ß√£o individualmente, vendo o tempo de resposta, o status HTTP, e at√© mesmo os dados de requisi√ß√£o e resposta para depura√ß√£o detalhada.

Salvar o Plano de Teste JMeter:

Para salvar seu plano de teste e os elementos que voc√™ configurou (incluindo as configura√ß√µes de Thread Group e HTTP Request), v√° em File > Save (ou Ctrl + S).

Escolha um nome significativo para o arquivo (ex: login_stress_test.jmx) e salve-o em um local acess√≠vel dentro do seu projeto (por exemplo, crie uma pasta jmeter-tests na raiz do seu reposit√≥rio).

Este arquivo .jmx √© o que voc√™ dever√° versionar no GitHub.

7. üìñ Documenta√ß√£o com Swagger / OpenAPI
Sua API ter√° documenta√ß√£o interativa gerada automaticamente.

// src/main/java/com/example/authserver/config/SwaggerConfig.java
package com.example.authserver.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
            .info(new Info()
                .title("API de Autentica√ß√£o JWT Interna")
                .version("1.0.0")
                .description("API para autentica√ß√£o, gera√ß√£o e valida√ß√£o interna de tokens JWT. Ideal para arquiteturas de microsservi√ßos com autentica√ß√£o centralizada.")
                .termsOfService("http://swagger.io/terms/")
                .contact(new Contact().name("Seu Nome/Equipe").email("seu.email@example.com"))
                .license(new License().name("Apache 2.0").url("http://www.apache.org/licenses/LICENSE-2.0.html")))
            .components(new Components()
                .addSecuritySchemes("bearerAuth", // Nome do esquema de seguran√ßa (usado com @SecurityRequirement)
                    new SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                        .description("Token JWT para autentica√ß√£o. Inclua no cabe√ßalho 'Authorization: Bearer <seu_token>'")));
    }
}

Acesse a documenta√ß√£o em: http://localhost:8080/swagger-ui.html.
